#!/usr/bin/env python3

import sys
import argparse
import subprocess
import random

# from pprint import pprint
import logging
import os

CURDIR = os.path.dirname(os.path.realpath(__file__))
LOGDIR = f"{CURDIR}/logs"
LOGLEVEL = logging.DEBUG
ansi_red = "\033[91m"
ansi_green = "\033[92m"
ansi_blue = "\033[94m"
ansi_cyan = "\033[96m"
ansi_magenta = "\033[95m"
ansi_yellow = "\033[93m"
ansi_reset = "\033[0m"

logger = logging.getLogger(__name__)
detailed_formatter = logging.Formatter(
    "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
file_handler = logging.FileHandler(f"{LOGDIR}/push_git_fast.log")
file_handler.setFormatter(detailed_formatter)
logger.addHandler(file_handler)
logger.setLevel(LOGLEVEL)


def run_command(command, capture_output=False, check=True):
    """
    Helper function to run shell commands.
    """
    result = subprocess.run(
        command, capture_output=capture_output, text=True, check=check
    )
    return result.stdout.strip() if capture_output else None


def print_in_and_out(cmd):
    cmd_str = " ".join(cmd)
    # print(f"{ansi_green}{cmd_str}{ansi_reset}")
    print(cmd_str)
    response = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    if response.returncode != 0:
        raise Exception(
            f"Command '{cmd_str}' failed with return code {response.returncode}\n Response: {response.stdout.decode('utf-8')}"
        )
    output = response.stdout.decode("utf-8")
    print(output)
    return output


def main():
    parser = argparse.ArgumentParser(description="Push multiple branches")
    parser.add_argument(
        "-c",
        "--commit-message",
        required=False,
        help="Commit message",
    )
    parser.add_argument(
        "-b",
        "--branch",
        nargs="+",
        required=False,
        action="append",
        help="Branch to push. Defaults to current branch",
    ),
    parser.add_argument(
        "-dp",
        "--dontpush",
        action="store_true",
        help="Don't push to remote",
        required=False,
        default=False,
    )
    parser.add_argument(
        "-s",
        "--skip_linter",
        help="Skip linter",
        required=False,
        default="",
    )
    parser.add_argument(
        "--no-verify",
        action="store_true",
        help="Skip pre-commit hooks",
        dest="no_verify",
        required=False,
        default=False,
    )
    parser.add_argument(
        "positional",
        nargs="?",
        help="Positional argument for commit message if only one argument is provided",
    )
    args = parser.parse_args()

    commit_message = args.commit_message or args.positional
    if not commit_message:
        parser.print_help()
        sys.exit(1)

    if args.branch:
        branches = [b[0] for b in args.branch]
    else:
        branches = [
            subprocess.check_output(["git", "branch", "--show-current"])
            .decode("utf-8")
            .strip()
        ]

    try:

        for numbranch, branch in enumerate(branches):
            new_branches = []
            print_in_and_out(["git", "checkout", branch])
            try:
                print_in_and_out(["git", "pull"])
            except Exception:
                # Maybe the upstream branch doesn't exist yet
                upstream_exists = print_in_and_out(
                    f"git ls-remote --heads origin refs/heads/foo/{branch}".split()
                )
                if not upstream_exists:
                    new_branches.append(branch)
                else:
                    raise

            # 8 digit random number
            random_number = random.randint(10000000, 99999999)
            pre_commit_stash = f"pre-commit-stash-{random_number}"

            commit_parts = ["git", "commit", "-m", f"'{commit_message}'"]
            if args.no_verify:
                PRECMD = ""
            else:
                PRECMD = "pre-commit run --hook-stage manual --from-ref HEAD^ --to-ref HEAD".split()
            merge_parts = ["git", "merge", f"{branches[0]}"]
            if args.no_verify:
                PRECMD = ""
            else:
                PRECMD = "pre-commit run --hook-stage manual -v --from-ref HEAD^ --to-ref HEAD".split()
            try:
                if numbranch == 0:
                    CUR_BRANCH = print_in_and_out(
                        "git rev-parse --abbrev-ref HEAD".split()
                    )
                    CMDS = [
                        # Create a temp branch with the current changes
                        f"git checkout -b {pre_commit_stash}",
                        "git add --all .",
                        "git commit --no-verify -m Stashing_changes_for_pre-commit_hook",
                        f"git checkout {CUR_BRANCH}",
                        f"git merge --no-commit --no-ff {pre_commit_stash}",
                        "git add --all .",
                    ]
                    for cmd in CMDS:
                        print_in_and_out(cmd.split())
                    if args.skip_linter:
                        os.environ["SKIP"] = args.skip_linter
                    if PRECMD:
                        print_in_and_out(PRECMD)
                    print_in_and_out(commit_parts)
                else:
                    print_in_and_out(merge_parts)
            except Exception as e:
                message = f"{e.__class__} : {e} : Failed to commit/merge {branches[0]}"
                print(f"{ansi_red}{message}{ansi_reset}")
                raise Exception(message)
        if not args.dontpush:
            for branch in branches:
                if branch in new_branches:
                    print_in_and_out(f"git push --set-upstream origin {branch}".split())
                else:
                    print_in_and_out(f"git push origin {branch}".split())

    except Exception as e:
        print(f"{e.__class__, e}")
        sys.exit(1)
    else:
        sys.exit(0)


if __name__ == "__main__":
    main()
