# Set hostname variable
export HOSTNAME=$(hostname)

# Project-specific PATH and aliases
export PATH=~/.uv/.venv/bin:~/.local/bin:~/bin:/usr/libexec/rancid:~/go/bin:$PATH

# ~/.bashrc: executed by bash(1) for non-login shells.

# If not running interactively, don't do anything
case $- in
*i*) ;;
*) return ;;
esac

# Color codes for prompt and scripts
RED="\e[31m"
YELLOW="\e[33m"
GREEN="\e[32m"
CYAN="\e[36m"
MAGENTA="\e[35m"
RESET="\e[0m"

# History settings
HISTCONTROL=ignoreboth:erasedups
shopt -s cmdhist
shopt -s histappend
HISTSIZE=100000
HISTFILESIZE=200000

# Append to the history file, don't overwrite it
shopt -s histappend

# This allows the history to be shared between multiple terminal sessions
# and ensures that the history is preserved across sessions.
PROMPT_COMMAND='history -a; history -n'

# Check window size after each command
shopt -s checkwinsize

# Make less more friendly for non-text input files
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# Set variable identifying the chroot you work in (used in the prompt below)
if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi

# Set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
xterm-color | *-256color) color_prompt=yes ;;
esac

# Uncomment for a colored prompt, if the terminal has the capability
#force_color_prompt=yes

if [ -n "$force_color_prompt" ]; then
    if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
        color_prompt=yes
    else
        color_prompt=
    fi
fi

# Copy function
copy() {
  local input
  input=$(cat)
  printf "\e]52;c;%s\a" "$(printf %s "$input" | base64 | tr -d '\n')"
}

# Function to print the basename of the directory containing the virtual environment
function bdvar() {
    if [ -n "$VIRTUAL_ENV" ]; then
        BDVAR="$(basename "$(dirname "$VIRTUAL_ENV")")"
    else
        BDVAR=""
    fi
    echo "$BDVAR"
}

# Set the shell prompt
if [ "$color_prompt" = yes ]; then
    PS1='${VIRTUAL_ENV:+($(bdvar))} ${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
else
    PS1='${VIRTUAL_ENV:+($(bdvar))} ${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
fi
unset color_prompt force_color_prompt

# Enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

# Some more ls aliases
alias ll='ls -lart'
alias la='ls -A'
alias l='ls -CF'
alias cm='chezmoi'
alias cmcd="cd $(chezmoi source-path)"
alias cmvim="chezmoi edit -c ~/.config/chezmoi/chezmoi-alt.toml"
alias cleargpg="echo RELOADAGENT | gpg-connect-agent"

# Add an "alert" alias for long running commands
alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'

# Source user aliases if present
if [ -f ~/.local/bin/bashrc_aliases ]; then
    . ~/.local/bin/bashrc_aliases
fi

# Enable programmable completion features
if ! shopt -oq posix; then
    if [ -f /usr/share/bash-completion/bash_completion ]; then
        . /usr/share/bash-completion/bash_completion
    elif [ -f /etc/bash_completion ]; then
        . /etc/bash_completion
    fi
fi

# Environment variables for Ansible
export ANSIBLE_DEPRECATION_WARNINGS=False
export ANSIBLE_PYTHON_INTERPRETER=$(/usr/bin/env python3 -c "import sys; print(sys.executable)")
export ANSIBLE_NAVIGATOR_PLAYBOOK_ARTIFACT_SAVE_AS="{playbook_dir}/logs/{playbook_name}-artifact-{time_stamp}.json"
export ANSIBLE_VAULT_PASSWORD_FILE=~/bin/vault_pass.sh

alias anslint='ansible-lint -f sarif --nocolor > test/ansible-lint-output.sarif'
alias awsconsole="aws-console --profile $AWS_PROFILE --stdout"
alias awslogin="aws sso login --profile $AWS_PROFILE --use-device-code --no-browser"
alias bc="git branch --show-current"
alias gitc='git -c core.editor="code --wait" config --global -e'
alias gitcl='git -c core.editor="code --wait" config --local -e'
alias grep="ugrep --hidden"
alias pcall="pre-commit run --all-files --verbose | tee >(tee logs/pre-commit.log) > logs/pre-commit.log.ansi"
alias pcans="pre-commit run ansible-lint --all-files --verbose | tee >(tee logs/ansible-lint.log) > logs/ansible-lint.log.ansi"
alias ugrep="ugrep --hidden"

export PRE_COMMIT_HOME=~/.cache/pre-commit
export EDITOR=vim
export GIT_EDITOR=vim
export DEBUG=0
export DEBUG2=0

# UV environment variables
export UV_PROJECT="$HOME"
export UV_LINK_MODE=hardlink
export VIRTUAL_ENV_DISABLE_PROMPT=1

# AWS environment variables
export AWS_PROFILE=network-dev
export AWS_CA_BUNDLE=/etc/ssl/certs/ca-certificates.crt

# Node.js CA certs
export NODE_EXTRA_CA_CERTS=/etc/ssl/certs/api_github_com_certchain.pem

# Source Rust environment if present
. "$HOME/.cargo/env"

# Function chezmoi push
function cmpush(){
    MESSAGE=${1:-"chezmoi update"}
    local olddir=$PWD
    echo -e "${MAGENTA}Applying changes locally...${RESET}"
    chezmoi apply --verbose
    echo -e "${MAGENTA}Pushing changes...${RESET}"
    echo -e "${CYAN}Start path: $PWD${RESET}"
    cd $(chezmoi source-path)
    echo -e "${CYAN}Changed to Chezmoi source path: $PWD${RESET}"
    git add -A
    git commit -m "$MESSAGE"
    smart_push
    cd $olddir
    echo -e "${CYAN}Back to original path: $PWD${RESET}"
    echo -e "${MAGENTA}Sourcing .bashrc or .zshrc...${RESET}"
    if [ -n "$BASH_VERSION" ]; then
        source ~/.bashrc
    elif [ -n "$ZSH_VERSION" ]; then
        source ~/.zshrc
    fi
    echo -e "${GREEN}Done!${RESET}"
}

# Function: git diff with diff-so-fancy
function gdiff() {
    git diff "$@" | diff-so-fancy | tr -d '\r' | less --tabs=4 -RFX
}

# Function: diff with diff-so-fancy
function dsf() {
    diff -u "$@" | diff-so-fancy | tr -d '\r' | less --tabs=4 -RFX
}

# Source additional scripts
for script in auto_venv.sh cdvirtualenv del-pre ghlogin uvp
do
    source ~/bin/"$script"
done

# Deduplicate PATH without reordering
dedup_path() {
    PATH=$(echo -n $PATH | awk -v RS=: -v ORS=: '!($0 in a) {a[$0]; print}')
    export PATH
}

# Ensure auto_venv is run on every prompt
PROMPT_COMMAND="${PROMPT_COMMAND:+$PROMPT_COMMAND; }auto_venv; dedup_path"

alias delautobranch='git branch | fgrep autobackup | tr "\n" " " | delete_branches.sh'

alias ghmar="gh api --hostname git.marriott.com"

function ycurl() {
    (echo -e "---\n"; curl "$@" | yq -y)
}

# machine-specific configuration
# machine-specific config (no github.com on this host)
# github copilot cli
eval "$(gh copilot alias --hostname github.com -- bash)"
function suggest() {
    echo Exit | ghcs --hostname github.com "$@" | tail -n +7 | head -5
}
function explain() {
    ghce --hostname github.com "$@" | tail -n +7
}

# Load these environment variables from secret cache at launch
if gopass cat .env-vars &>/dev/null; then
    # Use eval to correctly process the shell-escaped output from jq
    eval "$(gopass cat .env-vars | jq -r 'to_entries|map(select(.value|type == "string"))|map("export \(.key)=\(.value|@sh)")|.[]')"
fi

# Function to load json formatted secrets from gopass
function gopassload() {
    local secrets
    secrets="$(gopass cat "$1")"
    if [ $? -ne 0 ]; then
        echo "Error retrieving secrets from $1"
        return 1
    fi
    # Use eval to correctly process the shell-escaped output from jq
    eval "$(echo "$secrets" | jq -r 'to_entries|map(select(.value|type == "string"))|map("export \(.key)=\(.value|@sh)")|.[]')"
}

# Cat a secret from the cache
function gopassget() {
    local secret_output
    secret_output="$(gopass cat "$1")"
    if [ $? -ne 0 ]; then
        echo "Error retrieving secret: $1"
        return 1
    fi
    echo "$secret_output"
}

# Copy a file from gopass and set an expiration time on it
function gopasscopy() {
    local tomorrow=$(date -u -d "tomorrow" +"%Y-%m-%dT%H:%M:%SZ")
    local secret_path="$1"
    # local extension="${secret_path##*.}"
    # local secret_output=$(basename "$secret_path" $extension)
    local secret_output="${2:-$HOME/.secrets/$secret_path.out}"
    gopass fscopy "$secret_path" $secret_output
    if [ $? -ne 0 ]; then
        echo "Error copying secret: $secret_path" to "$secret_output"
        return 1
    fi
    if [ -n "$expiration_time" ]; then
        setfattr -n user.expire_at -v "$expiration_time" "$secret_output"
    fi
    if [ $? -ne 0 ]; then
        echo "Error setting expiration time on $secret_output"
        return 1
    fi
    echo "Copied secret to $secret_output with expiration time set to $expiration_time"
    echo "You can check the expiration time with: getfattr -n user.expire_at $secret_output"
}

# Login to gh on the Enterprise instance
# I don't think this is necessary
#
# auth_status=$(gh auth status --hostname git.marriott.com 2>&1)
# if [[ $auth_status != *"âœ“ Logged in"* ]]; then
#     echo $GITHUB_ENT_TOKEN | gh auth login --hostname git.marriott.com --with-token
#     if [ $? -ne 0 ]; then
#         echo "Error logging in to GitHub Enterprise"
#         return 1
#     fi
# else
#     echo "Already logged in to GitHub Enterprise"
# fi

function ghuser() {
    gh api --hostname git.marriott.com "users/$1" | jq -r '{login: .login, id: .id, name: .name}'
}

function cmreconcile() {
    local templates="$(chezmoi managed --include=templates)"
    local filediffs=`chezmoi status -x dirs | awk '{print $2}'`
    if [ -z "$filediffs" ]; then
        echo -e "${YELLOW}No files to reconcile.${RESET}"
        return 0
    fi
    echo -e "${YELLOW}Files to reconcile:${RESET}"
    local olddir=$PWD
    cd $HOME
    echo -e "${CYAN}cd to home directory: $PWD${RESET}"
    for file in $filediffs; do
        if echo "$templates" | grep -qx "$file"; then
            echo -e "${MAGENTA}Reconciling template file: $file${RESET}"
            chezmoi add --template "$file"
            continue
        fi
        echo -e "${CYAN}$file${RESET}"
        chezmoi add "$file"
    done
    echo -e "${GREEN}Reconciliation complete!${RESET}"
    cd $olddir
    echo -e "${CYAN}Back to original path: $PWD${RESET}"
    return 0
}

function cmupdate() {
    local olddir=$PWD
    local chezdir
    chezdir="$(chezmoi source-path)"
    echo -e "${MAGENTA}Downloading new changes from chezmoi...${RESET}"

    if ! cd "$chezdir"; then
        echo -e "${RED}Failed to change to chezmoi source path: $chezdir${RESET}"
        return 1
    fi
    echo -e "${CYAN}Changed to Chezmoi source path: $PWD${RESET}"

    if ! smart_pull; then
        echo -e "${RED}Failed to pull latest changes.${RESET}"
        cd "$olddir"
        return 1
    fi

    local cmdiff
    cmdiff="$(git diff origin/main)"
    if [ -z "$cmdiff" ]; then
        echo -e "${MAGENTA}No changes to update.${RESET}"
        cd "$olddir"
        echo -e "${CYAN}Back to original path: $PWD${RESET}"
        return 0
    fi

    echo -e "${YELLOW}Changes detected:${RESET}"
    echo -e "${CYAN}$cmdiff${RESET}"
    echo -e "${MAGENTA}Applying changes locally...${RESET}"

    if ! chezmoi apply --verbose; then
        echo -e "${RED}Error applying chezmoi changes.${RESET}"
        cd "$olddir"
        echo -e "${CYAN}Back to original path: $PWD${RESET}"
        return 1
    fi

    echo -e "${GREEN}Changes applied successfully.${RESET}"
    cd "$olddir"
    echo -e "${CYAN}Back to original path: $PWD${RESET}"

    if [[ $cmdiff == *".bashrc"* ]] || [[ $cmdiff == *".zshrc"* ]]; then
        echo -e "${YELLOW}Detected changes in .bashrc or .zshrc, sourcing them...${RESET}"
        if [ -n "$BASH_VERSION" ]; then
            echo -e "${CYAN}Sourcing .bashrc...${RESET}"
            source ~/.bashrc
        elif [ -n "$ZSH_VERSION" ]; then
            echo -e "${CYAN}Sourcing .zshrc...${RESET}"
            source ~/.zshrc
        fi
    else
        echo -e "${MAGENTA}No changes in .bashrc or .zshrc.${RESET}"
    fi

    echo -e "${GREEN}chezmoi update done!${RESET}"
    return 0
}

cmupdate
gopass sync
